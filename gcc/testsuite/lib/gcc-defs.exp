# Copyright (C) 2001-2015 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

load_lib target-libpath.exp

load_lib wrapper.exp

load_lib target-utils.exp

#
# ${tool}_check_compile -- Reports and returns pass/fail for a compilation
#

proc ${tool}_check_compile {testcase option objname gcc_output} {
    global tool
    set fatal_signal "*cc: Internal compiler error: program*got fatal signal"
 
    if [string match "$fatal_signal 6" $gcc_output] then {
	${tool}_fail $testcase "Got Signal 6, $option"
	return 0
    }

    if [string match "$fatal_signal 11" $gcc_output] then {
	${tool}_fail $testcase "Got Signal 11, $option"
	return 0
    }

    if [string match "*internal compiler error*" $gcc_output] then {
	${tool}_fail $testcase "$option (internal compiler error)"
	return 0
    }

    # We shouldn't get these because of -w, but just in case.
    if [string match "*cc:*warning:*" $gcc_output] then {
	warning "$testcase: (with warnings) $option"
	send_log "$gcc_output\n"
	unresolved "$testcase, $option"
	return 0
    }

    set gcc_output [prune_warnings $gcc_output]

    if { [info proc ${tool}-dg-prune] != "" } {
	global target_triplet
	set gcc_output [${tool}-dg-prune $target_triplet $gcc_output]
	if [string match "*::unsupported::*" $gcc_output] then {
	    regsub -- "::unsupported::" $gcc_output "" gcc_output
	    unsupported "$testcase: $gcc_output"
	    return 0
	}
    } else {
	set unsupported_message [${tool}_check_unsupported_p $gcc_output]
	if { $unsupported_message != "" } {
	    unsupported "$testcase: $unsupported_message"
	    return 0
	}
    }

    # remove any leftover LF/CR to make sure any output is legit
    regsub -all -- "\[\r\n\]*" $gcc_output "" gcc_output

    # If any message remains, we fail.
    if ![string match "" $gcc_output] then {
	${tool}_fail $testcase $option
	return 0
    }

    # fail if the desired object file doesn't exist.
    # FIXME: there's no way of checking for existence on a remote host.
    if {$objname != "" && ![is3way] && ![file exists $objname]} {
	${tool}_fail $testcase $option
	return 0
    }

    ${tool}_pass $testcase $option
    return 1
}

#
# ${tool}_pass -- utility to record a testcase passed
#

proc ${tool}_pass { testcase cflags } {
    if { "$cflags" == "" } {
	pass "$testcase"
    } else {
	pass "$testcase, $cflags"
    }
}

#
# ${tool}_fail -- utility to record a testcase failed
#

proc ${tool}_fail { testcase cflags } {
    if { "$cflags" == "" } {
	fail "$testcase"
    } else {
	fail "$testcase, $cflags"
    }
}

#
# ${tool}_finish -- called at the end of every script that calls ${tool}_init
#
# Hide all quirks of the testing environment from the testsuites.  Also
# undo anything that ${tool}_init did that needs undoing.
#

proc ${tool}_finish { } {
    # The testing harness apparently requires this.
    global errorInfo

    if [info exists errorInfo] then {
	unset errorInfo
    }

    # Might as well reset these (keeps our caller from wondering whether
    # s/he has to or not).
    global prms_id bug_id
    set prms_id 0
    set bug_id 0
}

#
# ${tool}_exit -- Does final cleanup when testing is complete
#

proc ${tool}_exit { } {
    global gluefile

    if [info exists gluefile] {
	file_on_build delete $gluefile
	unset gluefile
    }
}

#
# runtest_file_p -- Provide a definition for older dejagnu releases
# 		    and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
# 		    (delete after next dejagnu release).
#

if { [info procs runtest_file_p] == "" } then {
    proc runtest_file_p { runtests testcase } {
	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
		return 1
	    } else {
		return 0
	    }
	}
	return 1
    }
}

if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \
     && [info procs runtest_file_p] != [list] \
     && [info procs gcc_parallelize_saved_runtest_file_p] == [list] } then {
    global gcc_runtest_parallelize_counter
    global gcc_runtest_parallelize_counter_minor
    global gcc_runtest_parallelize_enable
    global gcc_runtest_parallelize_dir
    global gcc_runtest_parallelize_last

    set gcc_runtest_parallelize_counter 0
    set gcc_runtest_parallelize_counter_minor 0
    set gcc_runtest_parallelize_enable 1
    set gcc_runtest_parallelize_dir [getenv GCC_RUNTEST_PARALLELIZE_DIR]
    set gcc_runtest_parallelize_last 0

    proc gcc_parallel_test_run_p { testcase } {
	global gcc_runtest_parallelize_counter
	global gcc_runtest_parallelize_counter_minor
	global gcc_runtest_parallelize_enable
	global gcc_runtest_parallelize_dir
	global gcc_runtest_parallelize_last

	if { $gcc_runtest_parallelize_enable == 0 } {
	    return 1
	}

	# Only test the filesystem every 10th iteration
	incr gcc_runtest_parallelize_counter_minor
	if { $gcc_runtest_parallelize_counter_minor == 10 } {
	    set gcc_runtest_parallelize_counter_minor 0
	}
	if { $gcc_runtest_parallelize_counter_minor != 1 } {
	    #verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter $gcc_runtest_parallelize_last"
	    return $gcc_runtest_parallelize_last
	}

	set path $gcc_runtest_parallelize_dir/$gcc_runtest_parallelize_counter

	if {![catch {open $path {RDWR CREAT EXCL} 0600} fd]} {
	    close $fd
	    set gcc_runtest_parallelize_last 1
	    #verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter 1"
	    incr gcc_runtest_parallelize_counter
	    return 1
	}
	set gcc_runtest_parallelize_last 0
	#verbose -log "gcc_parallel_test_run_p $testcase $gcc_runtest_parallelize_counter 0"
	incr gcc_runtest_parallelize_counter
	return 0
    }

    proc gcc_parallel_test_enable { val } {
	global gcc_runtest_parallelize_enable
	set gcc_runtest_parallelize_enable $val
    }

    rename runtest_file_p gcc_parallelize_saved_runtest_file_p
    proc runtest_file_p { runtests testcase } {
	if ![gcc_parallelize_saved_runtest_file_p $runtests $testcase] {
	    return 0
	}
	return [gcc_parallel_test_run_p $testcase]
    }

} else {

    proc gcc_parallel_test_run_p { testcase } {
	return 1
    }

    proc gcc_parallel_test_enable { val } {
    }

}

# Like dg-options, but adds to the default options rather than replacing them.

proc dg-additional-options { args } {
    upvar dg-extra-tool-flags extra-tool-flags

    if { [llength $args] > 3 } {
	error "[lindex $args 0]: too many arguments"
	return
    }

    if { [llength $args] >= 3 } {
	switch [dg-process-target [lindex $args 2]] {
	    "S" { eval lappend extra-tool-flags [lindex $args 1] }
	    "N" { }
	    "F" { error "[lindex $args 0]: `xfail' not allowed here" }
	    "P" { error "[lindex $args 0]: `xfail' not allowed here" }
	}
    } else {
	eval lappend extra-tool-flags [lindex $args 1]
    }
}

# Record additional sources files that must be compiled along with the
# main source file.

set additional_sources ""

proc dg-additional-sources { args } {
    global additional_sources
    set additional_sources [lindex $args 1]
}

# Record additional files -- other than source files -- that must be
# present on the system where the compiler runs.

set additional_files ""

proc dg-additional-files { args } {
    global additional_files
    set additional_files [lindex $args 1]
}

# Return an updated version of OPTIONS that mentions any additional
# source files registered with dg-additional-sources.  SOURCE is the
# name of the test case.

proc dg-additional-files-options { options source } {
    global additional_sources
    global additional_files
    set to_download [list]
    if { $additional_sources != "" } then {
	if [is_remote host] {
	    lappend options "additional_flags=$additional_sources"
	}
	regsub -all "^| " $additional_sources " [file dirname $source]/" additional_sources
	if ![is_remote host] {
	    lappend options "additional_flags=$additional_sources"
	}
	set to_download [concat $to_download $additional_sources]
	set additional_sources ""
    }
    if { $additional_files != "" } then { 
	regsub -all "^| " $additional_files " [file dirname $source]/" additional_files
	set to_download [concat $to_download $additional_files]
	set additional_files ""
    }
    if [is_remote host] {
	foreach file $to_download {
	    remote_download host $file
	}
    }

    return $options
}

# Return a colon-separate list of directories to search for libraries
# for COMPILER, including multilib directories.

proc gcc-set-multilib-library-path { compiler } {
    global rootme

    # ??? rootme will not be set when testing an installed compiler.
    # In that case, we should perhaps use some other method to find
    # libraries.
    if {![info exists rootme]} {
	return ""
    }

    set libpath ":${rootme}"
    set options [lrange $compiler 1 end]
    set compiler [lindex $compiler 0]
    if { [is_remote host] == 0 && [which $compiler] != 0 } {
	foreach i "[eval exec $compiler $options --print-multi-lib]" {
	    set mldir ""
	    regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
	    set mldir [string trimright $mldir "\;@"]
	    if { "$mldir" == "." } {
		continue
	    }
	    if { [llength [glob -nocomplain ${rootme}/${mldir}/libgcc_s*.so.*]] >= 1 } {
		append libpath ":${rootme}/${mldir}"
	    }
	}
    }

    return $libpath
}

# This is almost identical to default_target_compile, except that
# multilib_flags is prepended to add_flags instead of append so that
# testcase can provide compiler options to override multilib_flags.

proc gcc_default_target_compile {source destfile type options} {
    global target_triplet
    global tool_root_dir
    global CFLAGS_FOR_TARGET
    global compiler_flags

    if { $destfile == "" && $type != "preprocess" && $type != "none" } {
	error "Must supply an output filename for the compile to default_target_compile"
    }

    set add_flags ""
    set libs ""
    set compiler_type "c"
    set compiler ""
    set ldflags ""
    set dest [target_info name]

    if {[info exists CFLAGS_FOR_TARGET]} {
	append add_flags " $CFLAGS_FOR_TARGET"
    }

    if {[info exists target_info(host,name)]} {
	set host [host_info name]
    } else {
	set host "unix"
    }

    foreach i $options {

	if { $i == "ada" } {
	    set compiler_type "ada"
	    if {[board_info $dest exists adaflags]} {
		append add_flags " [target_info adaflags]"
	    }
	    if {[board_info $dest exists gnatmake]} {
		set compiler [target_info gnatmake];
	    } else {
		set compiler [find_gnatmake];
	    }
	}
	
	if { $i == "c++" } {
	    set compiler_type "c++"
	    if {[board_info $dest exists cxxflags]} {
		append add_flags " [target_info cxxflags]"
	    }
	    append add_flags " [g++_include_flags]"
	    if {[board_info $dest exists c++compiler]} {
		set compiler [target_info c++compiler]
	    } else {
		set compiler [find_g++]
	    }
	}

	if { $i == "f77" } {
	    set compiler_type "f77"
	    if {[board_info $dest exists f77flags]} {
		append add_flags " [target_info f77flags]"
	    }
	    if {[board_info $dest exists f77compiler]} {
		set compiler [target_info f77compiler]
	    } else {
		set compiler [find_g77]
	    }
	}

	if { $i == "f90" } {
	    set compiler_type "f90"
	    if {[board_info $dest exists f90flags]} {
		append add_flags " [target_info f90flags]"
	    }
	    if {[board_info $dest exists f90compiler]} {
		set compiler [target_info f90compiler]
	    } else {
		set compiler [find_gfortran]
	    }
	}

	if {[regexp "^dest=" $i]} {
	    regsub "^dest=" $i "" tmp
	    if {[board_info $tmp exists name]} {
		set dest [board_info $tmp name]
	    } else {
		set dest $tmp
	    }
	}
	if {[regexp "^compiler=" $i]} {
	    regsub "^compiler=" $i "" tmp
	    set compiler $tmp
	}
	if {[regexp "^additional_flags=" $i]} {
	    regsub "^additional_flags=" $i "" tmp
	    append add_flags " $tmp"
	}
	if {[regexp "^ldflags=" $i]} {
	    regsub "^ldflags=" $i "" tmp
	    append ldflags " $tmp"
	}
	if {[regexp "^libs=" $i]} {
	    regsub "^libs=" $i "" tmp
	    append libs " $tmp"
	}
	if {[regexp "^incdir=" $i]} {
	    regsub "^incdir=" $i "-I" tmp
	    append add_flags " $tmp"
	}
	if {[regexp "^libdir=" $i]} {
	    regsub "^libdir=" $i "-L" tmp
	    append add_flags " $tmp"
	}
	if {[regexp "^ldscript=" $i]} {
	    regsub "^ldscript=" $i "" ldscript
	}
 	if {[regexp "^redirect=" $i]} {
 	    regsub "^redirect=" $i "" redirect
 	}
 	if {[regexp "^optimize=" $i]} {
 	    regsub "^optimize=" $i "" optimize
 	}
 	if {[regexp "^timeout=" $i]} {
 	    regsub "^timeout=" $i "" timeout
 	}
    }

    if {[board_info $host exists cflags_for_target]} {
	append add_flags " [board_info $host cflags_for_target]"
    }

    global CC_FOR_TARGET
    global CXX_FOR_TARGET
    global F77_FOR_TARGET
    global F90_FOR_TARGET
    global GNATMAKE_FOR_TARGET

    if {[info exists GNATMAKE_FOR_TARGET]} {
	if { $compiler_type == "ada" } {
	    set compiler $GNATMAKE_FOR_TARGET
	}
    }

    if {[info exists CC_FOR_TARGET]} {
	if { $compiler == "" } {
	    set compiler $CC_FOR_TARGET
	}
    }

    if {[info exists CXX_FOR_TARGET]} {
	if { $compiler_type == "c++" } {
	    set compiler $CXX_FOR_TARGET
	}
    }

    if {[info exists F77_FOR_TARGET]} {
	if { $compiler_type == "f77" } {
	    set compiler $F77_FOR_TARGET
	}
    }

    if {[info exists F90_FOR_TARGET]} {
	if { $compiler_type == "f90" } {
	    set compiler $F90_FOR_TARGET
	}
    }

    if { $compiler == "" } {
	set compiler [board_info $dest compiler]
	if { $compiler == "" } {
	    return "default_target_compile: No compiler to compile with"
	}
    }

    if {![is_remote host]} {
	if { [which $compiler] == 0 } {
	    return "default_target_compile: Can't find $compiler."
	}
    }

    if {$type == "object"} {
	append add_flags " -c"
    }

    if { $type == "preprocess" } {
	append add_flags " -E"
    }

    if { $type == "assembly" } {
	append add_flags " -S"
    }

    if {[board_info $dest exists cflags]} {
	append add_flags " [board_info $dest cflags]"
    }

    if { $type == "executable" } {
	if {[board_info $dest exists ldflags]} {
	    append add_flags " [board_info $dest ldflags]"
	}
	if { $compiler_type == "c++" } {
	    append add_flags " [g++_link_flags]"
	}
	if {[isnative]} {
	    # This is a lose.
	    catch "glob -nocomplain $tool_root_dir/libstdc++/libstdc++.so* $tool_root_dir/libstdc++/libstdc++.sl" tmp
	    if { ${tmp} != "" } {
		if {[regexp ".*solaris2.*" $target_triplet]} {
		    # Solaris 2
		    append add_flags " -R$tool_root_dir/libstdc++"
		} elseif {[regexp ".*(osf|irix5|linux).*" $target_triplet]} {
		    # OSF/1 or IRIX 5
		    append add_flags " -Wl,-rpath,$tool_root_dir/libstdc++"
		} elseif {[regexp ".*hppa.*" $target_triplet]} {
		    # HP-UX
		    append add_flags " -Wl,-a,shared_archive"
		}
	    }
	}
    }

    if {![info exists ldscript]} {
	set ldscript [board_info $dest ldscript]
    }

    foreach i $options {
	if { $i == "debug" } {
	    if {[board_info $dest exists debug_flags]} {
		append add_flags " [board_info $dest debug_flags]"
	    } else {
		append add_flags " -g"
	    }
	}
    }

    if {[info exists optimize]} {
	append add_flags " $optimize"
    }

    if { $type == "executable" } {
	append add_flags " $ldflags"
	foreach x $libs {
	    if {[file exists $x]} {
		append source " $x"
	    } else {
		append add_flags " $x"
	    }
	}

	if {[board_info $dest exists libs]} {
	    append add_flags " [board_info $dest libs]"
	}

	# This probably isn't such a good idea, but it avoids nasty
	# hackiness in the testsuites.
	# The math library must be linked in before the C library.  The C
	# library is linked in by the linker script, so this must be before
	# the linker script.
	if {[board_info $dest exists mathlib]} {
	    append add_flags " [board_info $dest mathlib]"
	} else {
	    append add_flags " -lm"
	}

	# This must be added here.
	append add_flags " $ldscript"

	if {[board_info $dest exists remote_link]} {
	    # Relink option.
	    append add_flags " -Wl,-r"
	}
	if {[board_info $dest exists output_format]} {
	    append add_flags " -Wl,-oformat,[board_info $dest output_format]"
	}
    }

    if {[board_info $dest exists multilib_flags]} {
	set add_flags "[board_info $dest multilib_flags] $add_flags"
    }

    verbose "doing compile"

    set sources ""
    if {[is_remote host]} {
	foreach x $source {
	    set file [remote_download host $x]
	    if { $file == "" } {
		warning "Unable to download $x to host."
		return "Unable to download $x to host."
	    } else {
		append sources " $file"
	    }
	}
    } else {
	set sources $source
    }

    if {[is_remote host]} {
	append add_flags " -o a.out"
	remote_file host delete a.out
    } else {
	if { $destfile != "" } {
	    append add_flags " -o $destfile"
	}
    }

    # This is obscure: we put SOURCES at the end when building an
    # object, because otherwise, in some situations, libtool will
    # become confused about the name of the actual source file.
    if {$type == "object"} {
        set opts "$add_flags $sources"
    } else {
        set opts "$sources $add_flags"
    }

    if {[is_remote host]} {
	if {[host_info exists use_at]} {
	    set fid [open "atfile" "w"]
	    puts $fid "$opts"
	    close $fid
	    set opts "@[remote_download host atfile]"
	    remote_file build delete atfile
	}
    }

    verbose "Invoking the compiler as $compiler $opts" 2

    if {[info exists redirect]} {
	verbose "Redirecting output to $redirect" 2
	set status [remote_exec host "$compiler $opts" "" "" $redirect]
    } else {
	if {[info exists timeout]} {
	    verbose "Setting timeout to $timeout" 2
	    set status [remote_exec host "$compiler $opts" "" "" "" $timeout]
	} else {
	    set status [remote_exec host "$compiler $opts"]
	}
    }

    set compiler_flags $opts
    if {[is_remote host]} {
	remote_upload host a.out $destfile
	remote_file host delete a.out
    }
    set comp_output [prune_warnings [lindex $status 1]]
    regsub "^\[\r\n\]+" $comp_output "" comp_output
    if { [lindex $status 0] != 0 } {
	verbose -log "compiler exited with status [lindex $status 0]"
    }
    if { [lindex $status 1] != "" } {
	verbose -log "output is:\n[lindex $status 1]" 2
    }
    if { [lindex $status 0] != 0 && "${comp_output}" == "" } {
	set comp_output "exit status is [lindex $status 0]"
    }
    return ${comp_output}
}

catch {rename default_target_compile {}}
rename gcc_default_target_compile default_target_compile
